{"version":3,"file":"logline.min.js","sources":["../src/lib/config.js","../src/lib/util.js","../src/protocols/interface.js","../src/lib/pool.js","../src/protocols/indexeddb.js","../src/protocols/localstorage.js","../src/protocols/websql.js","../src/logline.js"],"sourcesContent":["const DEFAULT_CONFIG = {\n    verbose: true\n};\n\nlet store = Object.assign({}, DEFAULT_CONFIG);\n\nexport function get(key) {\n    return key ? store[key] : store;\n}\n\nexport function set(key, value) {\n    let changes = {};\n    if (typeof key === 'string') {\n        changes[key] = value;\n    } else if (Object.prototype.toString.call(key) === '[object Object]') {\n        changes = key;\n    }\n    Object.assign(store, changes);\n}\n\nlet config = set;\nconfig.set = set;\nconfig.get = get;\n\nexport default config;\n","import config from './config';\n\nconst HAS_CONSOLE = window.console;\nconst LEVEL_CONSOLE_MAP = {\n    INFO: 'log',\n    WARN: 'warn',\n    ERROR: 'error',\n    CRITICAL: 'error'\n};\n\n// throw out Errors, with global prefix 'Logline: ' ahead of err.message\nexport function throwError(errMessage) {\n    HAS_CONSOLE && console.error('Logline: ' + errMessage);\n}\n\n// print debug info in develper's console\n// TODO: if WechatFE/vConsole is detected, will not use %c feature, as it is not well supported\nexport function debug(namespace, level, descriptor, data) {\n    if (HAS_CONSOLE && config.get().verbose) {\n        window.console[LEVEL_CONSOLE_MAP[level.toUpperCase()] || LEVEL_CONSOLE_MAP.INFO](`${namespace} ${level.toUpperCase()} ${descriptor}`, data || '');\n    }\n}\n\n// filter any function in a object\nexport function filterFunction(obj) {\n    var newObj = {}, i;\n\n    if (typeof obj !== 'object') {\n        return obj;\n    }\n\n    for (i in obj) {\n        if (obj.hasOwnProperty(i)) {\n            if (typeof obj[i] !== 'function') {\n                newObj[i] = filterFunction(obj[i]);\n            }\n        }\n    }\n    return newObj;\n}\n","import * as util from '../lib/util';\n\n/**\n * Logline Interface\n * @class Interface\n */\nexport default class Interface {\n    /**\n     * Logline constructor\n     * @constructor\n     * @param {String} namespace - namespace to use\n     */\n    constructor(namespace) {\n        this._namespace = namespace;\n    }\n\n    /**\n     * add a log record\n     * @method _reocrd\n     * @private\n     * @parma {String} level - log level\n     * @param {String} descriptor - to speed up search and improve understanding\n     * @param {Mixed} [data] - additional data\n     */\n    _record(level, descriptor, data) {\n        util.throwError('method _record is not implemented.');\n    }\n\n    /**\n     * add a level-info record\n     * @method info\n     * @param {String} descriptor - to speed up search and improve understanding\n     * @param {Mixed} [data] - additional data\n     */\n    info(...args) {\n        this._record('info', ...args);\n    }\n\n    /**\n     * add a level-warn record\n     * @method warn\n     * @param {String} descriptor - to speed up search and improve understanding\n     * @param {Mixed} [data] - additional data\n     */\n    warn(...args) {\n        this._record('warn', ...args);\n    }\n\n    /**\n     * add a level-error record\n     * @method error\n     * @param {String} descriptor - to speed up search and improve understanding\n     * @param {Mixed} [data] - additional data\n     */\n    error(...args) {\n        this._record('error', ...args);\n    }\n\n    /**\n     * add a level-critical record\n     * @method critical\n     * @param {String} descriptor - to speed up search and improve understanding\n     * @param {Mixed} [data] - additional data\n     */\n    critical(...args) {\n        this._record('critical', ...args);\n    }\n\n    /**\n     * initialize protocol\n     * @method init\n     * @static\n     * @param {String} database - database name to use\n     */\n    static init(database) {\n        return true;\n    }\n\n    /**\n     * transform human readable time string, such as '3d', '.3' and '1.2' into Unix timestamp\n     * the default relative time is Date.now(), if no second parameter is provided\n     * @method transTimeFormat\n     * @static\n     * @param {String} time - time string to transform\n     * @param {Number} [relative] - relative time to compare, default Date.now()\n     * @return {Number|NaN} timestamp transformed\n     */\n    static transTimeFormat(time, relative) {\n        // if falsy value or timestamp already, pass it through directly,\n        if (!time || /^\\d{13}$/.test(time)) {\n            return +time;\n        }\n        // incase relative time isn't unix timestamp format,\n        // neither a falsy value which will turned out to be Date.now()\n        if (relative && !/^\\d{13}$/.test(relative)) {\n            throw new TypeError('relative time should be standard unix timestamp');\n        }\n\n        return (relative || Date.now()) - time.replace(/d$/, '') * 24 * 3600 * 1000;\n    }\n\n    /**\n     * get logs in range\n     * if from and end is not defined, will fetch full log\n     * @method get\n     * @static\n     * @param {String} from - time from, unix timestamp\n     * @param {String} to - time end, unix timestamp\n     * @param {Function} readyFn - function to call back with logs as parameter\n     */\n    static get(from, to, readyFn) {\n        util.throwError('method get is not implemented.');\n    }\n\n    /**\n     * clean logs = keep limited logs\n     * @method keep\n     * @static\n     * @param {Number} daysToMaintain - keep logs within days\n     */\n    static keep(daysToMaintain) {\n        util.throwError('method keep is not implemented.');\n    }\n\n    /**\n     * delete log database\n     * @method clean\n     * @static\n     */\n    static clean() {\n        util.throwError('method clean is not implemented.');\n    }\n\n    /**\n     * protocol status map\n     * @prop {Object} STATUS\n     */\n    static get STATUS() {\n        return {\n            INITING: 1,\n            INITED: 2,\n            FAILED: 4\n        };\n    }\n}\n","/**\n * Pool, for storage of async calling\n * @class Pool\n */\nexport default class Pool {\n    /**\n     * Pool constructor\n     * @constructor\n     */\n    constructor() {\n        this._pool = [];\n    }\n\n    /**\n     * add an procedure\n     * @method push\n     * @param {Function} handler - procedure handler\n     * @param {Object} context - procedure context\n     */\n    push(handler, context) {\n        handler.context = context;\n        this._pool.push(handler);\n    }\n\n    /**\n     * consume pool\n     * @method consume\n     */\n    consume() {\n        var handler;\n        while ((handler = this._pool.shift())) {\n            handler.call(handler.context);\n        }\n    }\n}\n","import LoggerInterface from './interface';\nimport Pool from '../lib/pool';\nimport * as util from '../lib/util';\n\nconst READ_WRITE = 'readwrite';\n\n/**\n * IndexedDB protocol\n * @class IndexedDBLogger\n */\nexport default class IndexedDBLogger extends LoggerInterface {\n    /**\n     * IndexedDB protocol constructor\n     * @constructor\n     * @param {String} namespace - namespace to use\n     */\n    constructor(...args) {\n        super(...args);\n    }\n\n    /**\n     * add a log record\n     * @method _reocrd\n     * @private\n     * @parma {String} level - log level\n     * @param {String} descriptor - to speed up search and improve understanding\n     * @param {Mixed} [data] - additional data\n     */\n    _record(level, descriptor, data) {\n        try {\n            if (IndexedDBLogger.status !== LoggerInterface.STATUS.INITED) {\n                IndexedDBLogger._pool.push(() => this._record(level, descriptor, data));\n                if (IndexedDBLogger.status !== LoggerInterface.STATUS.INITING) {\n                    IndexedDBLogger.init();\n                }\n                return;\n            }\n\n            util.debug(this._namespace, level, descriptor, data);\n            let transaction = IndexedDBLogger.db.transaction(['logs'], READ_WRITE || 'readwrite');\n            transaction.onerror = event => util.throwError(event.target.error);\n\n            let store = transaction.objectStore('logs');\n            // should not contains any function in data\n            // otherwise 'DOMException: Failed to execute 'add' on 'IDBObjectStore': An object could not be cloned.' will be thrown\n            let request = store.add({\n                time: Date.now(),\n                level: level,\n                namespace: this._namespace,\n                descriptor: descriptor,\n                data: util.filterFunction(data)\n            });\n\n            request.onerror = event => {\n                IndexedDBLogger.status = LoggerInterface.STATUS.FAILED;\n                util.throwError(event.target.error);\n            };\n        } catch (e) {\n            util.throwError('failed to write, ' + e.message);\n        }\n    }\n\n    /**\n     * initialize protocol\n     * @method init\n     * @static\n     * @param {String} database - database name to use\n     */\n    static init(database) {\n        try {\n            if (!IndexedDBLogger.support) {\n                util.throwError('your platform does not support indexeddb protocol.');\n            }\n\n            if (IndexedDBLogger.status) {\n                return false;\n            }\n\n            IndexedDBLogger._pool = IndexedDBLogger._pool || new Pool();\n            IndexedDBLogger._database = database || 'logline';\n            IndexedDBLogger.status = super.STATUS.INITING;\n\n            IndexedDBLogger.request = window.indexedDB.open(IndexedDBLogger._database);\n            IndexedDBLogger.request.onerror = event => util.throwError('protocol indexeddb is prevented.');\n            IndexedDBLogger.request.onsuccess = event => {\n                IndexedDBLogger.db = event.target.result;\n                IndexedDBLogger.status = super.STATUS.INITED;\n                IndexedDBLogger._pool.consume();\n                // globally handle db request errors\n                IndexedDBLogger.db.onerror = event => util.throwError(event.target.error);\n            };\n            IndexedDBLogger.request.onupgradeneeded = event => {\n                // init dabasebase\n                let db = event.target.result, store = db.createObjectStore('logs', { autoIncrement: true });\n                store.createIndex('namespace', 'namespace', { unique: false });\n                store.createIndex('level', 'level', { unique: false });\n                store.createIndex('descriptor', 'descriptor', { unique: false });\n                store.createIndex('data', 'data', { unique: false });\n            };\n        } catch (e) {\n            util.throwError('failed init, ' + e.message);\n        }\n    }\n\n    /**\n     * get logs in range\n     * if from and end is not defined, will fetch full log\n     * @method get\n     * @static\n     * @param {String} [from] - time from, unix time stamp or falsy\n     * @param {String} [to] - time end, unix time stamp or falsy\n     * @param {Function} readyFn - function to call back with logs as parameter\n     */\n    static get(from, to, readyFn) {\n        try {\n            if (IndexedDBLogger.status !== super.STATUS.INITED) {\n                return IndexedDBLogger._pool.push(() => IndexedDBLogger.get(from, to, readyFn));\n            }\n\n            from = LoggerInterface.transTimeFormat(from);\n            to = LoggerInterface.transTimeFormat(to);\n\n            let store = IndexedDBLogger._getTransactionStore(IDBTransaction.READ_ONLY);\n            if (!store) {\n                return readyFn([]);\n            }\n\n            // IDBObjectStore.getAll is a non-standard API\n            if (store.getAll) {\n                let result, logs = [];\n                store.getAll().onsuccess = event => {\n                    result = event.target.result;\n                    for (let i = 0; i < result.length; i++) {\n                        if ((from && result[i].time < from) || (to && result[i].time > to)) {\n                            continue;\n                        }\n                        logs.push(result[i]);\n                    }\n                    readyFn(logs);\n                };\n            } else {\n                let request = store.openCursor(), logs = [];\n                request.onsuccess = event => {\n                    var cursor = event.target.result;\n                    if (cursor) {\n                        if ((from && cursor.value.time < from) || (to && cursor.value.time > to)) {\n                            return cursor.continue();\n                        }\n\n                        logs.push({\n                            time: cursor.value.time,\n                            level: cursor.value.level,\n                            namespace: cursor.value.namespace,\n                            descriptor: cursor.value.descriptor,\n                            data: cursor.value.data\n                        });\n                        cursor.continue();\n                    }\n                    else {\n                        readyFn(logs);\n                    }\n                };\n            }\n        } catch (e) {\n            util.throwError('failed to get logs, ' + e.message);\n        }\n    }\n\n    /**\n     * clean logs = keep limited logs\n     * @method keep\n     * @static\n     * @param {Number} daysToMaintain - keep logs within days\n     */\n    static keep(daysToMaintain) {\n        try {\n            if (IndexedDBLogger.status !== super.STATUS.INITED) {\n                return IndexedDBLogger._pool.push(() => IndexedDBLogger.keep(daysToMaintain));\n            }\n\n            let store = IndexedDBLogger._getTransactionStore(READ_WRITE);\n            if (!store) {\n                return false;\n            }\n            if (!daysToMaintain) {\n                let request = store.clear().onerror = event => util.throwError(event.target.error);\n            }\n            else {\n                let range = (Date.now() - (daysToMaintain || 2) * 24 * 3600 * 1000);\n                let request = store.openCursor();\n                request.onsuccess = event => {\n                    let cursor = event.target.result;\n                    if (cursor && cursor.value.time < range) {\n                        store.delete(cursor.primaryKey);\n                        cursor.continue();\n                    }\n                };\n                request.onerror = event => util.throwError('unable to locate logs earlier than ' + daysToMaintain + 'd.');\n            }\n        } catch (e) {\n            util.throwError('failed to keep logs, ' + e.message);\n        }\n    }\n\n    /**\n     * delete log database\n     * @method clean\n     * @static\n     */\n    static clean() {\n        try {\n            if (IndexedDBLogger.status !== super.STATUS.INITED) {\n                return IndexedDBLogger._pool.push(() => IndexedDBLogger.clean());\n            }\n\n            // database can be removed only after all connections are closed\n            IndexedDBLogger.db.close();\n            let request = window.indexedDB.deleteDatabase(IndexedDBLogger._database);\n            request.onerror = event => util.throwError(event.target.error);\n            /* eslint no-unused-vars: \"off\" */\n            request.onsuccess = event => {\n                delete IndexedDBLogger.status;\n                delete IndexedDBLogger.db;\n            };\n        } catch (e) {\n            util.throwError('failed to cleanup logs, ' + e.message);\n        }\n    }\n\n    /**\n     * get internal transaction store\n     * @method _getTransactionStore\n     * @private\n     * @static\n     * @param {String} mode - transaction mode\n     * @return {Object} - internal object store\n     */\n    static _getTransactionStore(mode) {\n        try {\n            if (IndexedDBLogger.db) {\n                let transaction = IndexedDBLogger.db.transaction(['logs'], mode || READ_WRITE);\n                transaction.onerror = event => util.throwError(event.target.error);\n                return transaction.objectStore('logs');\n            }\n            else {\n                util.throwError('log database is not created or connections are closed, considering init it.');\n            }\n        } catch (e) {\n            util.throwError('failed to generate new transaction, ' + e.message);\n            return false;\n        }\n    }\n\n    /**\n     * detect support situation\n     * @prop {Boolean} support\n     */\n    static get support() {\n        const support = !!(window.indexedDB && window.IDBTransaction && window.IDBKeyRange);\n        return support;\n    }\n}\n","import LoggerInterface from './interface';\nimport * as util from '../lib/util';\n\n/**\n * Localstorage protocol\n * @class LocalStorageLogger\n */\nexport default class LocalStorageLogger extends LoggerInterface {\n    /**\n     * Localstorage protocol constructor\n     * @constructor\n     * @param {String} namespace - namespace to use\n     */\n    constructor(...args) {\n        super(...args);\n    }\n\n    /**\n     * add a log record\n     * @method _reocrd\n     * @private\n     * @parma {String} level - log level\n     * @param {String} descriptor - to speed up search and improve understanding\n     * @param {Mixed} [data] - additional data\n     */\n    _record(level, descriptor, data) {\n        var logs;\n        try {\n            logs = window.localStorage.getItem(LocalStorageLogger._database) ? JSON.parse(window.localStorage.getItem(LocalStorageLogger._database)) : [];\n            logs.push([\n                Date.now(),\n                this._namespace,\n                level,\n                descriptor,\n                data\n            ]);\n            util.debug(this._namespace, level, descriptor, data);\n            window.localStorage.setItem(LocalStorageLogger._database, JSON.stringify(logs));\n        } catch (e) {\n            window.localStorage.removeItem(LocalStorageLogger._database);\n            window.localStorage.setItem(LocalStorageLogger._database, JSON.stringify([]));\n            util.throwError('failed to write, may be localStorage is full, ' + e.message);\n        }\n    }\n\n    /**\n     * initialize protocol\n     * @method init\n     * @static\n     * @param {String} database - database name to use\n     */\n    static init(database) {\n        try {\n            if (!LocalStorageLogger.support) {\n                util.throwError('your platform does not support localstorage protocol.');\n            }\n            LocalStorageLogger._database = database || 'logline';\n            if (!window.localStorage.getItem(LocalStorageLogger._database)) {\n                window.localStorage.setItem(LocalStorageLogger._database, JSON.stringify([]));\n            }\n            LocalStorageLogger.status = super.STATUS.INITED;\n        } catch (e) {\n            util.throwError('failed to init, ' + e.message);\n        }\n    }\n\n    /**\n     * get logs in range\n     * if from and end is not defined, will fetch full log\n     * @method get\n     * @static\n     * @param {String} from - time from, unix time stamp or falsy\n     * @param {String} to - time end, unix time stamp or falsy\n     * @param {Function} readyFn - function to call back with logs as parameter\n     */\n    static get(from, to, readyFn) {\n        var logs, i;\n        try {\n            logs = JSON.parse(window.localStorage.getItem(LocalStorageLogger._database));\n\n            from = LoggerInterface.transTimeFormat(from);\n            to = LoggerInterface.transTimeFormat(to);\n\n            for (i = 0; i < logs.length; i++) {\n                if ((from && logs[i][0] < from) || (to && logs[i][0] > to)) {\n                    continue;\n                }\n\n                logs[i] = {\n                    time: logs[i][0],\n                    namespace: logs[i][1],\n                    level: logs[i][2],\n                    descriptor: logs[i][3],\n                    data: logs[i][4]\n                };\n            }\n            readyFn(logs);\n        } catch (e) {\n            util.throwError('failed to get, ' + e.message);\n            readyFn([]);\n        }\n    }\n\n    /**\n     * clean logs = keep limited logs\n     * @method keep\n     * @static\n     * @param {Number} daysToMaintain - keep logs within days\n     */\n    static keep(daysToMaintain) {\n        var logs;\n        try {\n            logs = !daysToMaintain ? [] : (window.localStorage.getItem(LocalStorageLogger._database) ? JSON.parse(window.localStorage.getItem(LocalStorageLogger._database)) : []).filter(log => {\n                return log.time >= (Date.now() - (daysToMaintain || 2) * 24 * 3600 * 1000);\n            });\n            window.localStorage.setItem(LocalStorageLogger._database, JSON.stringify(logs));\n        } catch (e) {\n            util.throwError('failed to keep, ' + e.message);\n        }\n    }\n\n    /**\n     * delete log database\n     * @method clean\n     * @static\n     */\n    static clean() {\n        try {\n            delete LocalStorageLogger.status;\n            window.localStorage.removeItem(LocalStorageLogger._database);\n        } catch (e) {\n            util.throwError('failed to clean, ' + e.message);\n        }\n    }\n\n    /**\n     * detect support situation\n     * @prop {Boolean} support\n     */\n    static get support() {\n        return 'localStorage' in window;\n    }\n}\n","import LoggerInterface from './interface';\nimport Pool from '../lib/pool';\nimport * as util from '../lib/util';\n\n/**\n * Websql protocol\n * @class WebsqlLogger\n */\nexport default class WebsqlLogger extends LoggerInterface {\n    /**\n     * Websql logline constructor\n     * @constructor\n     * @param {String} namespace - namespace to use\n     */\n    constructor(...args) {\n        super(...args);\n    }\n\n    /**\n     * add a log record\n     * @method _reocrd\n     * @private\n     * @parma {String} level - log level\n     * @param {String} descriptor - to speed up search and improve understanding\n     * @param {Mixed} [data] - additional data\n     */\n    _record(level, descriptor, data) {\n        if (WebsqlLogger.status !== LoggerInterface.STATUS.INITED) {\n            WebsqlLogger._pool.push(() => this._record(level, descriptor, data));\n            if (WebsqlLogger.status !== LoggerInterface.STATUS.INITING) {\n                WebsqlLogger.init();\n            }\n            return;\n        }\n\n        try {\n            util.debug(this._namespace, level, descriptor, data);\n            WebsqlLogger._db.transaction(tx => {\n                tx.executeSql(\n                    'INSERT INTO logs (time, namespace, level, descriptor, data) VALUES(?, ?, ?, ? ,?)',\n                    [Date.now(), this._namespace, level, descriptor, (data === undefined || data === '') ? '' : (JSON.stringify(data) || '')],\n                    () => {/* empty func */},\n                    (tx, e) => { util.throwError('write error, ' + e.message); }\n                );\n            });\n        } catch (e) { util.throwError('error inserting record, ' + e.message); }\n    }\n\n    /**\n     * initialize protocol\n     * @method init\n     * @static\n     * @param {String} database - database name to use\n     */\n    static init(database) {\n        if (!WebsqlLogger.support) {\n            util.throwError(new Error('your platform does not support websql protocol.'));\n        }\n\n        if (WebsqlLogger.status) {\n            return false;\n        }\n\n        WebsqlLogger._pool = WebsqlLogger._pool || new Pool();\n        WebsqlLogger._database = database || 'logline';\n        WebsqlLogger.status = super.STATUS.INITING;\n\n        try {\n            WebsqlLogger._db = window.openDatabase(WebsqlLogger._database, '1.0', 'cats loves logs', 4.85 * 1024 * 1024);\n            WebsqlLogger._db.transaction(tx => {\n                tx.executeSql(\n                    'CREATE TABLE IF NOT EXISTS logs (time, namespace, level, descriptor, data)', [],\n                    () => {\n                        WebsqlLogger.status = super.STATUS.INITED;\n                        WebsqlLogger._pool.consume();\n                    },\n                    (tx, e) => {\n                        WebsqlLogger.status = super.STATUS.FAILED;\n                        util.throwError('unable to create table, ' + e.message);\n                    }\n                );\n            });\n        } catch (e) { util.throwError('unable to init log database, ' + e.message); }\n    }\n\n    /**\n     * get logs in range\n     * if from and end is not defined, will fetch full log\n     * @method get\n     * @static\n     * @param {String} from - time from, unix time stamp or falsy\n     * @param {String} to - time end, unix time stamp or falsy\n     * @param {Function} readyFn - function to call back with logs as parameter\n     */\n    static get(from, to, readyFn) {\n        if (WebsqlLogger.status !== super.STATUS.INITED) {\n            return WebsqlLogger._pool.push(() => WebsqlLogger.get(from, to, readyFn));\n        }\n\n        from = LoggerInterface.transTimeFormat(from);\n        to = LoggerInterface.transTimeFormat(to);\n\n        try {\n            WebsqlLogger._db.transaction(function(tx) {\n                tx.executeSql(\n                    'SELECT * FROM logs ORDER BY time DESC', [],\n                    (tx, res) => {\n                        var logs = [], line, index = res.rows.length, item;\n                        while (--index >= 0) {\n                            item = res.rows.item(index);\n                            if ((from && item.time < from) || (to && item.time > to)) {\n                                continue;\n                            }\n\n                            // in some devices, properties are configureable: false, writable: false\n                            // we need deep copy\n                            line = JSON.parse(JSON.stringify(item));\n                            // incase data is an object, not a string\n                            try { line.data = JSON.parse(line.data); }\n                            catch (e) {/* leave line.data as it be */}\n                            logs.push(line);\n                        }\n                        readyFn(logs);\n                    },\n                    (tx, e) => { util.throwError(e.message); }\n                );\n            });\n        } catch (e) { util.throwError('unable to collect logs from database.'); }\n    }\n\n    /**\n     * clean logs = keep limited logs\n     * @method keep\n     * @static\n     * @param {Number} daysToMaintain - keep logs within days\n     */\n    static keep(daysToMaintain) {\n        if (WebsqlLogger.status !== super.STATUS.INITED) {\n            return WebsqlLogger._pool.push(() => WebsqlLogger.keep(daysToMaintain));\n        }\n\n        try {\n            WebsqlLogger._db.transaction(function(tx) {\n                if (daysToMaintain) {\n                    tx.executeSql(\n                        'DELETE FROM logs WHERE time < ?',\n                        [Date.now() - (daysToMaintain || 2) * 24 * 3600 * 1000],\n                        function() { /* empty func */ },\n                        function(tx, e) { util.throwError(e.message); }\n                    );\n                }\n                else {\n                    tx.executeSql(\n                        'DELETE FROM logs', [],\n                        () => {/* empty func */},\n                        (tx, e) => { util.throwError(e.message); }\n                    );\n                }\n            });\n        } catch (e) { util.throwError('unable to clean logs from database.'); }\n    }\n\n    /**\n     * delete log database\n     * @method clean\n     * @static\n     */\n    static clean() {\n        if (WebsqlLogger.status !== super.STATUS.INITED) {\n            WebsqlLogger._pool.push(() => WebsqlLogger.clean());\n            return;\n        }\n\n        try {\n            WebsqlLogger._db.transaction(tx => {\n                tx.executeSql(\n                    'DROP TABLE logs', [],\n                    () => {\n                        delete WebsqlLogger.status;\n                    },\n                    (tx, e) => { util.throwError(e.message); }\n                );\n            });\n        } catch (e) { util.throwError('unable to clean log database.'); }\n    }\n\n    /**\n     * detect support situation\n     * @prop {Boolean} support\n     */\n    static get support() {\n        return 'openDatabase' in window;\n    }\n}\n","import Interface from './protocols/interface';\nimport IndexeddbLogger from './protocols/indexeddb';\nimport LocalstorageLogger from './protocols/localstorage';\nimport WebsqlLogger from './protocols/websql';\nimport * as util from './lib/util';\nimport config from './lib/config';\n\n\nclass Logline {\n    /**\n     * Logline constructor\n     * @constructor\n     * @param {String} namespace - namespace to use\n     * @return {Object Protocol Instance}\n     */\n    constructor(namespace) {\n        if (!(this instanceof Logline)) {\n            return new Logline(namespace);\n        }\n        try {\n            Logline._checkProtocol();\n            return new Logline._protocol(namespace);\n        } catch (e) {\n            return new Interface(namespace);\n        }\n    }\n\n    /**\n     * change config\n     * @method config\n     * @param {String|Object} key - config key, or config object\n     * @param {Any} [value] - new config value\n     * @return {Void}\n     */\n    static get config() {\n        return config;\n    }\n\n    /**\n     * choose a protocol to initialize\n     * @method _initProtocol\n     * @private\n     * @static\n     * @param {Object Protocol Class} protocol - protocol to use, must under Logline.PROTOCOL\n     * @return {Object} Logline\n     */\n    static _initProtocol(protocol) {\n        Logline._protocol = protocol;\n        Logline._protocol.init(Logline._database || 'logline');\n    }\n\n    /**\n     * check protocol\n     * if no protocol is chosen, will try to choose an available one automatically\n     * if none of the protocols is available, an error will be thrown\n     * @method _checkProtocol\n     * @private\n     * @static\n     */\n    static _checkProtocol() {\n        if (!Logline._protocol) {\n            let protocols = Object.keys(Logline.PROTOCOL), protocol;\n            while ((protocol = Logline.PROTOCOL[protocols.shift()])) {\n                if (protocol.support) {\n                    Logline._initProtocol(protocol);\n                    return;\n                }\n            }\n\n            util.throwError('protocols ' + protocols.join(', ').toLowerCase() + ' are not supported on this platform');\n        }\n    }\n\n    /**\n     * get logs in range\n     * if from and end is not defined, will fetch full log\n     * @method get\n     * @static\n     * @param {String} [from] - time from\n     * @param {String} [to] - time end\n     * @param {Function} readyFn - function to call back with logs as parameter\n     */\n    static get(from, to, readyFn) {\n        Logline._checkProtocol();\n\n        switch (arguments.length) {\n            case 1:\n                readyFn = from;\n                from = undefined;\n                break;\n            case 2:\n                readyFn = to;\n                to = undefined;\n                break;\n            case 3:\n            default:\n                break;\n        }\n\n        Logline._protocol.get(from, to, readyFn);\n    }\n\n    /**\n     * read all logs\n     * @method all\n     * @static\n     * @param {Function} readyFn - function to call back with logs as parameter\n     */\n    static all(readyFn) {\n        Logline.get(readyFn);\n    }\n\n    /**\n     * clean up logs = keep limited logs\n     * @method keep\n     * @static\n     * @param {String} daysToMaintain - specialfy days to keep, support human readable format such as '3d', '.3'\n     * @return {Object} Logline\n     */\n    static keep(daysToMaintain) {\n        Logline._checkProtocol();\n        Logline._protocol.keep(daysToMaintain);\n        return this;\n    }\n\n    /**\n     * delete log database\n     * @method clean\n     * @static\n     * @return {Object} Logline\n     */\n    static clean() {\n        Logline._checkProtocol();\n        Logline._protocol.clean();\n        return this;\n    }\n\n    /**\n     * choose a protocol\n     * @method using\n     * @static\n     * @param {Object Protocol Class} protocol - wanted protocol, should be on of Logline.PROTOCOL\n     * @param {String} [database] - custome database name\n     * @return {Object} Logline\n     */\n    static using(protocol, database) {\n        // protocol unavailable is not allowed\n        if (-1 === [IndexeddbLogger, LocalstorageLogger, WebsqlLogger].indexOf(protocol)) {\n            util.throwError('specialfied protocol ' + (protocol ? (protocol + ' ') : '') + 'is not available');\n        }\n\n        // once protocol is selected, it shall not be changed during runtime\n        if (Logline._protocol) {\n            return this;\n        }\n\n        Logline.database(database || Logline._database);\n        Logline._initProtocol(protocol);\n        return this;\n    }\n\n    /**\n     * specialfy a custome database name, in case of any conflicts\n     * @methd database\n     * @static\n     * @param {String} name - target database name\n     */\n    static database(name) {\n        Logline._database = name;\n    }\n}\n\n// export protocols for modification and mounting\nLogline.PROTOCOL = {\n    INDEXEDDB: IndexeddbLogger,\n    LOCALSTORAGE: LocalstorageLogger,\n    WEBSQL: WebsqlLogger\n};\n\n// export protocol interface for user custom implements\nLogline.INTERFACE = Object.freeze(Interface);\n\n// export Logline env, just like Unix Environment variables\nLogline.env = {\n    verbose: true\n};\n\nexport default Logline;\n"],"names":["get","key","store","set","value","changes","Object","prototype","toString","call","throwError","errMessage","console","error","debug","namespace","level","descriptor","data","HAS_CONSOLE","config","verbose","LEVEL_CONSOLE_MAP","toUpperCase","INFO","filterFunction","obj","i","newObj","hasOwnProperty","DEFAULT_CONFIG","babelHelpers.extends","window","Interface","_namespace","args","_record","database","time","relative","test","TypeError","Date","now","replace","from","to","readyFn","daysToMaintain","Pool","_pool","handler","context","push","this","shift","IndexedDBLogger","status","LoggerInterface","STATUS","INITED","_this2","INITING","init","transaction","db","onerror","util","event","target","objectStore","add","FAILED","e","message","support","_database","babelHelpers.get","request","indexedDB","open","onsuccess","result","consume","onupgradeneeded","createObjectStore","autoIncrement","createIndex","unique","transTimeFormat","_getTransactionStore","IDBTransaction","READ_ONLY","getAll","logs","length","openCursor","cursor","continue","keep","range","delete","primaryKey","clear","clean","close","deleteDatabase","mode","IDBKeyRange","LocalStorageLogger","localStorage","getItem","JSON","parse","setItem","stringify","removeItem","filter","log","WebsqlLogger","_db","executeSql","undefined","tx","Error","openDatabase","res","line","item","index","rows","Logline","_checkProtocol","_protocol","protocol","protocols","keys","PROTOCOL","_initProtocol","join","toLowerCase","arguments","IndexeddbLogger","LocalstorageLogger","indexOf","name","INTERFACE","freeze","env"],"mappings":"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"}